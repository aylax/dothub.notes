#+TITLE: Re:Zero - DEATH OR KISS - . Rust
#+AUTHOR: aylax zhou
#+EMAIL: zhoubye@foxmail.com
#+DESCRIPTION: A description of rust
#+KEYWORDS: rust
#+OPTIONS: author:t creator:t timestamp:t email:t

** Getting started
:PROPERTIES:
:CUSTOM_ID: GettingStarted
:END:
<2021-08-27 Fri 12:30>

Let's start our rust journey!

*** Installation
:PROPERTIES:
:CUSTOM_ID: Installation
:END:
<2021-08-27 Fri 12:30>

=rustup= is a command line tool for managing =Rust= versions and associated tools.

**** Install rustup on Linux or macOS
We can install =rustup= use the command below.
#+begin_src sh
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
#+end_src

**** Update and Uninstall
we can update rustup use the command below.
#+begin_src sh
rustup update
#+end_src

To uninstall =Rust= and =rustup=, run the following script.
#+begin_src sh
rustup self uninstall
#+end_src

**** Local Documentation
The installation of =Rust= also includes a copy of the documentation. So you can
read it offline. Just type the command below.
#+begin_src sh
rustup doc
#+end_src

*** First Example
:PROPERTIES:
:CUSTOM_ID: FirstExample
:END:
<2021-08-27 Fri 12:42>

After installed =Rust=, let's write a little program.

**** Write and Run a Rust Program

create a file named =main.rs=, and type something.
#+begin_src rust
fn main() {
  println!("hello world!");
}
#+end_src

and then compile it by =rustc=
#+begin_src sh
rustc main.rs
#+end_src

finally you can run the binary file.
#+begin_src sh
./main
#+end_src

*** Hello Cargo
:PROPERTIES:
:CUSTOM_ID: Hello Cargo
:END:
<2021-08-27 Fri 12:55>

=Cargo= is Rust's build system and package manager.

**** Create a project with Cargo
Let's create a new project using cargo.
#+begin_src sh
cargo new first_example --bin
cd first_example
#+end_src

It has also initialized as a git repository along with a gitignore file.
Git files won't be generated if you run =cargo new= within an existed repo.
You can override this behavior by using =cargo new --vcs=git=.
#+begin_src
Note: Git is a common version control system. you can change =cargo new= to
use a different version control system or no version control system by using
the =--vcs= flag. Run =cargo new --help= to see the available options.
#+end_src

**** Build and Run with Cargo.
Now let's build our project.
#+begin_src sh
cargo build
#+end_src

This command creates an executable file in =./target/debug/=. You can run the
executable with the command.
#+begin_src sh
cargo run
#+end_src

Cargo also provides a command called =cargo check=. This command quickly checks
your code to make sure it compiles but doesn't produce an executable.

**** Building for Release
When our project is finally ready for release, we can use =cargo build --release=
to compile it with optimizations. This command will create an executable in
=./target/release/= instead of =./target/debug/=. The optimizations make our Rust code
run faster, but turning them on lengthens the time it takes for our program to compile.

**** Update a Crate to Get a New Version
When you do want to update a crate, Cargo provides another command, =cargo update=. Which will
ignore the =Cargo.lock= file and figure out all the latest versions that fit versions in Cargo.toml.
If that works, Cargo will write those versions to the =Cargo.lock= file.

** Common Concepts
:PROPERTIES:
:CUSTOM_ID: CommonConcepts
:END:
<2021-08-27 Fri 16:12>
This chapter covers concepts that appear in almost every programming language and how they work in Rust.
Specifically, we'll learn about variables, basic types, functions, comments, and control flow.

*** Variables and Mutability
:PROPERTIES:
:CUSTOM_ID: VariablesAndMutability
:END:
<2021-08-27 Fri 16:12>

By default variables are immutable and we can use =let mut= to make variables mutable. When a variables
immutable, once a value is bound to a name, we can't change that value. Here's error code below.
#+begin_src rust
fn main() {
 let x = 5;
 x = 6;
 println!("The value of x is: {}", x);
}
#+end_src

Save and run it using =cargo run=. You should receive an error message. The error message indicates that
the cause of the error is that you =can not assign twice to immutable variable x=, because you tried to
assign a second value to the immutable variable.

**** Differences Between Variables and Constants
Declare constants using the =const= keyword instead of =let=. The Constants type must be annotated. Constants
can be declared in any scope, including the global scope. Constants may be set only to a constant expression,
not the result of a function call or any other value that could only be computed at runtime.

**** Shadowing
You can declare a new variable with the same name as a previous variable. It means that the first variable is
shadowed by the second.
#+begin_src rust
fn main {
  let x = 5;
  let x = 12;
}
#+end_src

Shadowing is different from marking a variable as =mut=, because we'll get a compile-time error if we accidentally
try to reassign to this variable without using the =let= keyword.

The other difference between =mut= and shadowing is that because we're effectively creating a new variable when we
use the =let= keyword again, we can change the type of the value but reuse the same name.

*** Data Types
:PROPETIES:
:CUSTOM_ID: DataTypes
:END:
<2021-08-27 Fri 16:50>

Every value in Rust is of a certain data type. which tells Rust what kind of data is being specified so it knows
how to work with that data. We'll look at two data type subsets: =scalar= and =compound=.

**** Scalar Types
A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers,
booleans, and characters.

*Integer Types*

An integer is a number without a fractional component.

_Integer Types in Rust_

|   Length   |   Signed   |  Unsigned  |
|   8-bit    |    i8      |    u8      |
|   16-bit   |    i16     |    u16     |
|   32-bit   |    i32     |    u32     |
|   64-bit   |    i64     |    u64     |
|   128-bit  |    i128    |    u128    |
|   arch     |    isize   |    usize   |

_Integer Literals in Rust_

|  Literals  |  Example   |
|  Decimal   |    98_22   |
|  Hex       |    0xff    |
|  Octal     |    0o22    |
|  Binary    |    0b11    |
|  Byte(u8)  |    b'A'    |


*Floating-Point Types*

Rust also has two primitive types for floating-point numbers, which are numbers with dicimal points.
Rust's floating-point types are =f32= and =f64=.

*Boolean Type*

A boolean type in rust has two possible values: =true= and =false=. Booleans are one byte in size.
#+begin_src rust
let is_true: bool = true;
#+end_src

*Character Type*

char literals are specified with single quotes.
#+begin_src rust
let c = 'z';
#+end_src

**** Compound Types
Compound types can group multiple values into one type. Rust has two primitive compound types: =tuples= and =arrays=.

*Tuple Type*

A tuple is a general way of grouping together a numbers of values with a variety of types into one compound type.
Tuples have a fixed length: once declared, they can not grow or shrink in size.
#+begin_src rust
fn main {
  let tup: (i32, f64, u8) = (500, 6.4, 1);
  let (x, y, z) = tup;
  println!("tup.first is {}", tup.0);
}
#+end_src

*Array Type*

Another way to have a collection of multiple values is with an array. Unlike a tuple, every element of an
array must have the same type. Arrays also have a fixed length, like tuples.
#+begin_src rust
fn main() {
  let arr = [1, 2, 3];
  let brr: [i32; 4] = [1, 2, 3, 4];
  println!("arr[0] is {}", arr[0]);
}
#+end_src

*** Functions
Function definitions in Rust start with =fn= and have a set of parentheses after the function name.
The curly brackets tell the compiler where the function body begins and ends.
#+begin_src rust
fn foo(a: i32) -> i32 {
  a + 1
}
fn bar() {}
fn foobar() -> ! {}
#+end_src

Function body is made up of a series of statements optionally ending in an expression. Statements are
instructions that perform some action and do not return a value. Expressions evalute to a resulting value.
#+begin_src rust
fn main() {
  let y = 6; // statement
  y + 1 // expression
}
#+end_src
